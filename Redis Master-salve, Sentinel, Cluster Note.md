# Redis Master-salve, Sentinel, Cluster  Note

## Redis 如何管理系統內的資料？

發送到 Redis 的命令首先在記憶體做處理，如果在節點上設置持久性，則會在間隔上有分叉的進程，進行資料持久性 RDB 快照或 AOF

### RDB 快照

根據指令時間間隔，對資料進行時間點快照

此機制主要缺點是快照之間的資料會遺失，這個機制仰賴分叉主進程，在較大的資料集中，可能會導致處理請求的延遲，但 RDB 快照在記憶體中的載入速度比 AOF 快很多

### AOF

AOF 持續記錄伺服器收到的每個寫操作，這些操作將在伺服器啟動時，重建原始資料

它是追加的文件，可配置每隔一段時間存儲到磁碟中，其缺點是比 RDB 檔案佔用更多磁碟空間

## Master-salve replication 主從複製

從一個服務器又或稱為節點，複製出任意多個節點，稱為從節點，最開始稱為主節點，主節點會將寫入的資料同步更新給從節點，使節點之間資料一致，從節點只支援讀（read）操作

當主節點當機不可用時，需要重新選出一個主節點

每一個節點都有一個 replication ID 以及 偏移量，這兩個資料對於從節點複製是否需要完全同步很重要，對於主節點發生的每個操作，偏移量都會增加

### 複製 ID 和偏移量的作用

複製 ID（Replication ID）：唯一識別 Redis 主節點。每次 Redis 主節點重新啟動或從節點晉升為主節點時，都會產生新的複製 ID。
偏移量（offset）：表示 Redis 處理了多少資料變更，每當 Redis 執行寫入操作（例如 SET key value），偏移量就會增加。

### 複製過程

當從節點比主節點只落後一點時（即偏移量差距很小）：

- 從節點執行主節點發送的命令，使數據保持同步，不需要完整同步

如果複製 ID 無法一致，或節點缺失了偏移量：

- 從節點申請完全同步
- 主節點生成新的 RDB 快照，並傳輸給從節點
- 主節點將生成快照的這段時間，額外的命令同步給從節點

當 Redis 節點提升為主節點或重新啟動時，它會有一個新的複製 ID，由於新的主節點記住了舊的複製 ID，仍然可以與其他從節點執行部分同步

如果複製 ID 相同，偏移量不同，可以執行部分同步。
如果複製 ID 不同，且主實例不知道舊複製 ID，只能完整同步。
如果複製 ID 不同，但主實例記得舊複製 ID，可以 嘗試部分同步，提高同步效率。

### 對比單節點優點

1. 降低單節點的讀操作壓力
2. Slave 節點方便水平擴展，當系統 QPS 增加時，增加 Slave節點
3. 主節點當機時，可以直接用從節點代替繼續服務

### 存在的缺點

1. 寫操作的壓力還是集中在單一節點
2. 存儲能力受限於單一節點
3. 可靠性保證不佳，如果主節點不可用時，系統無法提供寫操作
4. 主節點不可用需要從節點代替時，需人工進行修改應用端主節點位置，命令所有從節點同步新主節點資料等等

## 哨兵模式

主從複製的其一缺點，當主節點當機時，需要人工進行干預，切換節點

而哨兵模式主要解決了這個問題，提升了系統的可用性，哨兵模式就主從複製的架構上，新增了另一種性質的節點（服務器），它不負責存儲資料，而是負責監視主從節點是否正常運作

### 哨兵模式功能宏觀列表

- 監控：Sentinel 不斷監測主從節點是否正常運作
- 通知：Sentinel 可透過 API 通知管理員或系統，其所監控的節點出現了問題
- 自動故障轉移：當主節點發生故障時，Sentinel可啟動故障轉移程序，將從節點提升為主節點，並且將其他從節點配置到新的主節點，並通知客戶端使用新的主節點位置
- 配置提供者：客戶端首先連接至 Sentinel，詢問目前服務的主節點位置，如果發生故障轉移，將報告新的位置

### 哨兵模式的設計

哨兵模式本身是以多個 Sentinel(哨兵節點) 運作為前提設計的，當多個 Sentinel 認為一個主節點不再可用時，便會啟動故障偵測，這降低了誤報的機率。

即便有部分的 Sentinel 無法運作，哨兵模式仍然可以運作，會發生單點故障的故障轉移系統沒有意義

### SDOWN 和 ODOWN 故障狀態

Redis Sentinel 有兩種不同的 down 概念，一種稱為主觀 down情況（SDOWN），一種是特定 Sentinel 實例本地的 down 情況。另一種情況稱為客觀關閉 狀態（ODOWN），當足夠多的 Sentinel（至少是`quorum`被監控主節點的參數配置的數量）出現 SDOWN 狀態，並且使用`SENTINEL is-master-down-by-addr`命令從其他 Sentinel 獲得反饋時，就會達到這種狀態。

從 Sentinel 的角度來看，當它在設定參數中指定的秒數內沒有收到 PING 請求的有效答覆時，就會達到 SDOWN 條件`is-master-down-after-milliseconds` 。

對 PING 的可接受回復是下列之一：

- PING 回覆 +PONG。
- PING 回覆 -LOADING 錯誤。
- PING 回覆 -MASTERDOWN 錯誤。

任何其他回覆（或根本沒有回覆）都被視為無效。但請注意，如果邏輯主伺服器在 INFO 輸出中將自己宣傳為副本，則該邏輯主伺服器將被視為已關閉。

請注意，SDOWN 要求在配置的整個間隔內未收到可接受的答复，因此，例如，如果間隔為 30000 毫秒（30 秒）並且我們每 29 秒收到一次可接受的 ping 答复，則該實例被視為正在運行。

SDOWN 不足以觸發故障轉移：它只表示單一 Sentinel 認為 Redis 執行個體不可用。若要觸發故障轉移，必須達到 ODOWN 狀態。

從 SDOWN 切換到 ODOWN 不需要使用強大的共識演算法，而只是一種八卦形式：如果給定的 Sentinel在給定的時間範圍內從足夠多的 Sentinel 獲得主節點沒有工作的報告，則 SDOWN 被提升為 ODOWN。如果此確認稍後遺失，則標誌被清除。

為了真正啟動故障轉移，需要使用實際多數的更嚴格的授權，但未達到 ODOWN 狀態就無法觸發故障轉移。

ODOWN 條件僅適用於 masters。對於其他類型的實例，Sentinel 不需要採取行動，因此副本和其他 Sentinel 永遠不會達到 ODOWN 狀態，而只有 SDOWN 狀態。

然而 SDOWN 也有語意意義。例如，處於 SDOWN 狀態的副本不會被執行故障轉移的 Sentinel 選擇提升。

### Sentinel 的自動發現

Sentinels 互相連線並監測彼此，但不需要手動設定所有 Sentinels 的地址

Sentinel 透過 Redis 的 Pub/Sub 訂閱 `__sentinel__:hello` 頻道來發現其他 Sentinel 節點

過程：

1. 每個 Sentinel 每 2 秒 都會向所有監控的 master 和 replica 發送 `hello` 訊息（發送到 `__sentinel__:hello` 頻道）。
2. 每個 Sentinel 也會訂閱 `__sentinel__:hello` 頻道，接收來自其他 Sentinels 的 `hello` 訊息。
3. 當 Sentinel 發現新的 Sentinel 時，就會把它加入該 master 的監控列表中。
4. 如果收到的 `hello` 訊息包含較新的 master 設定，則更新自身的 master 設定。

Sentinel 會先檢查是否已經存在相同 `runid` 或相同 `ip:port` 的 Sentinel，如果有舊的記錄，就會刪除舊的，換成新的 Sentinel。

### Sentinel 與客戶端

客戶端可使用 Sentinel 作為與節點間的 Pub/Sub 服務器，來發送或接收信息通知

Sentinel 提供 API 來檢查其狀態，檢查受監控的主節點和從節點的健康狀況，訂閱以接收特定通知以及在運行時更改 Sentinel 配置。

預設情況下，Sentinel 使用 TCP 連接埠 26379 運作（請注意，6379 是正常的 Redis 連接埠）。 Sentinels 使用 Redis 協定接受指令，因此您可以使用**`redis-cli`**或任何其他未修改的 Redis 用戶端與 Sentinel 通訊。

可以直接查詢 Sentinel，從其角度檢查所監視的 Redis 實例的狀態，查看它知道哪些其他 Sentinel，等等。或者，使用 Pub/Sub，每次發生某些事件（例如故障轉移或實例進入錯誤狀態等）時，都可以從 Sentinels 接收推播的通知*。*

### 有可能丟失數據

在每個 Sentinel 設定中，由於 Redis 使用非同步複製，因此總是存在丟失一些寫入的風險，因為當主節點發生故障時，給定的已確認寫入可能無法到達提升為主的從節點

可以使用 Redis 複製功能來緩解此問題，如果主伺服器偵測到它不再能夠將其寫入傳輸到指定數量的副本，則允許停止接受寫入。

如果它無法寫入至少 1 個從節點，它將停止接受寫入。由於複製是異步的，因此*無法寫入*實際上意味著從節點已斷開連接

### 優點

- 可以自動故障移轉，增加高可用性
- 透過哨兵監控節點，當節點故障時，可透過哨兵節點通知管理者或是應用

### 缺點

- 依然由主節點單一負責寫操作壓力
- 寫操作效率依然受到單一主節點限制
- 主從節點故障轉移時，存在時間差造成資料遺失

## Cluster 叢集模式