# process(進程), thread(線程, 執行緒), coroutine(協程)

## CPU

在一個極小的時間點，一個單核心的CPU僅能執行一個任務，單核心併發處理不同任務

CPU 在不同任務間快速地切換，使得多個任務都能有進展

在現代的多核心 CPU，能真正做到並行執行任務

## Program

程式碼的集合，尚未被執行，意味著未被載入至記憶體

## Process （進程）

Process 指被執行且載入記憶體的 program

每個 Process 有獨立的系統資源分配空間，不同 Process 資源不共享

Process 的資源包括：

### 內存

代碼段(code segment)：

- 存儲進程的可執行代碼
- 通常是唯讀的，避免運行時被修改
- 編譯後的二進制指令

數據段：

- 初始化數據段：存儲已初始化的全局變量跟靜態變量
- 內存映射段：映射共享庫、文件映射、動態加載的模塊

### 寄存器

- 進程在 CPU 執行時使用一組寄存器來存儲臨時數據，這些寄存器在進程切換（context switch）時被保存和恢復

### 文件描述符

- 管理打開的磁盤文件、網路連接、Socket、管道等 I/O 資源
- 在類 Unix 系統中，幾乎所有資源（包括設備、網絡）都抽象為文件描述符

### 管理信息

- 進程控制塊(PCB)，操作系統管理進程的關鍵
- 虛擬內存，每個進程有自己的虛擬內存空間，映射到物理內存或磁盤，代碼段、數據段、堆、棧皆儲存於此
- 環境變量，進程在被啟動時就已儲存在內存當中，配置運行環境
- 工作目錄，當前工作目錄，影響文件操作的相對路徑解析

### 通信與同步

- 信號，可接收處理操作系統（指令）或其他進程發送的信號，用於事件通知或控制
- 共享資源，多個進程映射同一塊內存，也有鎖機制提供同步，用消息隊列進行進程間的通信，這些資源通常由操作系統提供 API 管理

### 其他

- 資源限制器，限制進程 最大內存使用量、最大CPU時間、最大打開文件數等等
- 計時器，利用操作系統提供的計時器來跟蹤時間或執行排程

### 執行單元 （較重要）

Stack(棧)：

定義：後進先出的內存結構，用於存儲函數調用的相關數據

作用：

- 儲存局部變量（函數內部定義的變量）
- 保存函數調用的信息
- 管理函數的 Call Stack (調用棧)，追蹤函數的執行流程

特點：

- 內存分配和釋放由系統自動管理
- 大小固定，超出會造成棧溢出（Stack Overflow）
- 數據存儲是連續的，效率高

舉例：在函數內定義的變量 `x := 10` ，會分配在棧上，函數執行完畢後自動銷毀

Heap(堆)：

定義：動態分配的內存區域，儲存運行時需要動態分配的數據和釋放

作用：

- 儲存動態分配的對象（如結構體、切片、映射、通道等），需通過 `make()` 或 `new()` 分配的內存
- 儲存透過逃逸分析（Escape Analysis）後分配到堆上的變量

特點：

- 透過垃圾回收器。會定期掃視堆上的內存，回收不再被使用的對象，確保空間有效利用
- 可被跨函數共享，堆上的數據可被多個 goroutine, thread 共享
- 管理不當可能造成內存洩漏或野指針的問題

### **Go 的逃逸分析與堆分配**

Go 編譯器通過**逃逸分析（Escape Analysis）決定一個變量應該分配在棧**還是**堆**上：

- 如果一個變量的生命周期局限於當前函數（不會被外部引用），它通常分配在 Stack 上，效率更高。
- 如果變量**逃逸**到函數外部（例如通過返回值、指針傳遞、或被全局變量引用），則分配在 Heap 上。

## Thread （線程、執行緒）

一個 Process 裡可以執行多個 Thread ，多個 Thread 共享 Process 的資源

哪些資源被共享？例如內存空間、數據段、堆等等，而棧則是 Thread 獨有的，它是執行的最小單位，需要保有自己的局部變量

### Thread 在 Process 裡是並行執行還是併發執行？

取決於系統的硬體架構和作業系統的實現方式

在**多核心系統**中，作業系統可以將 Process 內的 Thread 分配到不同核心，實現並行執行

如果系統只有單核心，或者 Thread 數量超過核心數，則 Thread 在核心上會以併發方式執行